Thoughts on our BSP system, and the data structures that support it.

What do we need?

We need a system that can:

	- Load non bsp data (cpp floating point)
	- Compile non bsp data into bsp data (cpp floating point)
	- Render bsp data (all)
	- Collide with bsp data (all)


What information does nonbsp data need?

	- Positions
	- Normals
	- Colors (?)
	- TexCoords
	- Textures
	- Polygon data
	       OR
	  Volume data
		- Or can this be extracted from a well built bsp?
		- Or should that somehow be an optional step?
		- The brushes are CSGd anyway in regular BSP compilaion!
		   So volume data goes away, doesnt it?


What information does bsp data need?

	- Positions
	- Normals
	- Colors (?)
	- TexCoords
	- Textures
	- Polygon data
	- Volume data (solid / empty / or both?)
	- BSP structure with polygons & volumes tagged?
	- Lightmaps (or could we get by with just colors?)


Should they be the same structures?
	- Its sure looking like it.  They share 80 % of the data.
	   Basically the compile process just adds BSP structures / Lightmap data


How does these data structures convert to the rendering & collision data types?

	- All the cooresponding data could fit into a peeper VertexBuffer I suppose
	- What of the polygon / volume data?

		Polygon data could be a collection of Polygon objects, which could have references to the position data
		It could also store a Plane object for each Polygon.  Then we could have easy classification of how their planes.

		Volume data would basically be a collection of planes representing convex volumes.  But thats kind of pointless without face information.
		So the face information could be a texture associated with each plane I suppose.


The Full list of processes to get from one data type to another:
	- Begin with either worldcraft like volume data, or just milkshape like polygon data.
		- If volume data, convert that to Volume + Polygon data.	<-- CSG Process

		- Otherwise we convert it to just Polygon data.  Perhaps a Quad reconstruction algorithm could be used here to reduce the number of Polygons.

	- Compile the Polygon data to a BSP					<-- BSP Process
		-Gather the leafs from the BSP to rebuild the volume + polygon data
		   But with the added benifit of indexes back into the BSP, and vice versa (Indexes from BSP to the volume + polygon data)

	- Traverse the empty volumes of the BSP to determine visibility!	<-- VIS process

	



* THOUGHT *
	The 'texture projection' information used in typical bsps to represent how a texture fits on a polygon is the same process that we need to 
	use in the flash version of the engine to set up the transform for a texture on a triangle.
 