Initial Knot thoughts & layout:

The networking code should be reuseable with different connection types (bluetooth, socket, maybe even serial if we want to hack-a-way)

How to do this?

	Somehow we need to separate the connection creation & the actual networking code.

	So there are 2 parts:
		- Connection creators
			- Server/Client socket connections
				- Either direct via IP
				- Or with some matching server
			- Server/Client bluetooth connections
				- Either direct via a device name
				- Or with ServerQuerying

		- Networking models
			- Server/Client model (half life style)
			- Peer/Peer model (something like constructo, but with prediction)

Connection creators operate pretty much in their own ways, however they all output either
	- StreamConnection
	- Or DatagramConnection



Client Server:
First we need a Client/Server socket connection creator.

	ClientSocketConnector{
		ClientSocketConnector();

		bool connect(const String &ip,int port);
		StreamConnection *getStreamConnection();
		DatagramConnection *getDatagramConnection();
	}

	ServerSocketConnector{
		ServerSocketConnector();

		bool accept(int port);
		StreamConnection *getCurrentStreamConnection();
		DatagramConnection *getCurrentDatagramConnection();
	}

What would a bluetooth connection creator look like?

	ClientBluetoothConnector - how does this compare to BluetoothClient?

	ServerBluetoothConnector - how does this compare to BluetoothServer?

Maybe its optional to use these Connectors, I could always create them manually.



THESE ARE WHAT NEED WORK:  NETWORKING MODELS!

	The PeerToPeer model works like so:

		We have a PREDICTED TIME and a GAME TIME
	
		The idea is that GAME TIME is far enough behind PREDICTED TIME, that by the time either client gets to simulating GAME TIME
			it has all necessary messages from the other client to guarantee the state of GAME TIME

		So if we could lay out all game interaction with MESSAGES, then we could process those MESSSAGES immediately for PREDICTED TIME,
			and merge them with the incoming client messages for GAME TIME

		The only real problem comes about with the way we interact with the SCENE GRAPH.  Its very easy to just add velocities to objects,
			delete objects, create new objects, etc.  But much more of a pain if we must send MESSAGES for EACH INTERACTION.

		So, MESSAGES should be automated in part?  HopEntity::setVelocity, setTranslate (mSolid->setPosition?) create & destroy could all automatically
			generate messages.

		Do we run TWO SCENE GRAPHS then?  Or try to do it all with ONE SCENE GRAPH, but store game POSITIONS in the entities?  Then what about
			CREATION and DESTRUCTION?

		Dont forget we have NON-ENTITY MESSAGES to affect the game.  However those should not need to be NETWORK PASSED, should they?
			In a PEER to PEER system, all randomness will be synched.  In a Client/Server setup, the server doesnt need to tell the client about
			them for the most part.  However, there will obviously be some other user input, (like 'cast special effect') that will need to be
			synchornized in the same way.  So allow these to be sent about ALSO.

		So it looks like ENTITY MESSAGES could be automated.  But then we need to be able to work with the MESSAGE SYSTEM to send other INPUT.


	Questions remaining:
		- How many SCENE GRAPHS?

			Just 1 scene graph.  The network PREDICTION will just not predict entity destruction & creation.
			BUT: How does ENTITY->DESTROY work in the scene manager when the game code is running?
			ANSWER: IT WORKS JUST FINE.  Since the GAME LOGIC is running in GAME TIME.
			The key to keeping things synchronized is to do GAME LOGIC based on the GAME TIME ENTITY STATES, not the PREDICTED STATE
			PREDICTED STATE is only for positions & velocitys

		- How do we store this predicted data vs game data?

			Initial Thought:  Just add an mRealPosition & mRealVelocity to the entities?
				- The game logic will be very difficult to write, since to get the position it will involve something like
				HopEntity->getRealPosition instead of getTranslate()?

				However, we currently have the SAME PROBLEM!  Since Velocity & Position are already interpolated they are not really
				'valid states' in terms of physics frames.

				So whats the answer?  Perhaps Translate / Rotate / Velocity get from HopEntities should correspond to the game/physics frames
				And then there would be additional parameters which would be USED INSTEAD in the pre-render matrix calculations!!
				This would be a BENIFIT, since WORLD TRANSLATE & WORLD ROTATION are not gettable parameters of an entity anyway, so the 
				CHILD ENTITIES would be UNAFFECTED. (As in, the game logic could still look at positions of child entities and it would be
				valid, since its just local translates)  Any PER FRAME ROTATIONS/TRANSLATIONS to child entities would have to take place in
				game frame time, or we would add in SPECIAL PREDICTION methods.  but thats for another time.

		- When would we know if we need to 'rewind' the entity data back to game state and go forward again?

			Whenever anything touches an entity's GAME STATE, then it needs to be rewound.  Perhaps a hook in HopEntity, so it knows if an
				external source touches Translate/Position or Velocity?  Basically, it would have to be any PHYSICS related thing.
			Do I mirror all the Solid parameters to the HopEntity interface, and then made getSolid PROTECTED or maybe even PRIVATE, that would
				keep subclassed entities from playing with the interface without correctly triggering things.  Though we could add some bool
				flag that can be triggered also to signal a rewind is necessary.
			We could also mirror the Simulator parameters to the HopSceneManager!  This would be good, to do this mirroring, since it would not
				only seem to clean up code (less ->getSolid()/->getSimulator()) but also make the network notifications transparent.
				PLUS: When we do Client/Server code, it could trigger MESSAGES about entity parameters changing this way, which even if
					not necessary, (since server rules all), it would still keep the clients representation smooth, which is necessary
					I suppose.

			So whenever these things happen, then in update() the HopSceneManager (or some network model peer), which has a bool flag modified
				as it updates entities could then check and go 'yea we need to rewind', then would trigger a rewind and fast forward again
				to get to our PREDICTED state.

		- How do the ENTITIES AUTOMATE MESSAGES?

			Messages can be pretty easily generated from the same hooks used to signal physics rewinding.
				- Example:  physics is 5 frames ahead.  player adds velocity to a block.  You see it happening right away due to prediction
					but a message is automatically generated due to this, which is put into a message queue, and then merged with
					in coming messages from the other peer.  Then the result is applied.  If its the same result as what the message
					initially predicted, then NO CHANGE IS NECESSARY to rewinding.

			So we need 2 ways of CHANGING position/velocity?  1 that doesnt rewind/forward and 1 that does?
				- Well, the real difference is 1 way of CHANGE can be anticpated (local message) so the result can take effect immediatly.
					hence no need to rewind/forward, unless, like notice above, the result conflicts, then rewind/forward is necessary

				- what about GAME STATE messages?  are those rewind/forwarded, or not?  THEY WOULD HAVE TO BE, since GAME LOGIC GOES in
					GAME STATE TIME.  The only messages that are accurately predicted should be those USER INTERACTION commands which
					will really annoy people if they dont take effect right away.

				- So 2 different ways, I suppose.  The default method should be GAME TIME, and wouldnt generate a message unless we are
					a server in a server/client setup.  There would also be like setVelocityImmediate() or setPositionImmediate().
	
		- How does the MESSAGE STRUCTURE work?

			We need a structure for sending messages between client/server & peer/peer.  Basic messages from 'play this map' and 'i said this'
				to complex synchronization messages that keep the peers from getting too far ahead if there is lag or anything

			Use a Class?  class Message{uint16 type} Since the only thing common between messages is they have some type identifier.

			What about a size parameter to a message?  uint16 or uint32 size?
				+ would let us skip a message if we dont want to read it
				- skipping a message is proabably not a good idea
				- it would take additional bandwidth, and bandwidth is a valuable resource

			Ok so no size parameter.  If we have basic messages then we add in some 'optional' messages, they can have their own size.

			Each message class will override a write read method from a stream.

		- What goes in Knot, and what goes in toadlet_hop?

			The basic message structure should be in Knot

			We could make a PeerToPeer Network/Model/Interaction/Synchronization class, and it would handle sending messages back & forth between
				the peers, and keeping a counter of the current frame vs the predicted frame, and letting it run so far ahead without
				getting some synchronization message and freezing till we got it

			Then in toadlet_hop would handle the actual rewinding/forwarding, specialized messages for hopentities, etc.

		- Do we add in some Network peer l

Summary for above:
	- Mirror all hop functionality into HopEntity & HopSceneManager

	- Separate the visual interpolated position / interpolated velocity from the scene graph's Translate somehow.  This can then be predicted & 
		interpolated between physics frames. HopEntity will then keep its GAME position & velocity the same as the scene graphs one.

	- Add in 2 sets of methods for adjusting position / velocity to HopEntity.  One that triggers a REWIND (setPosition), and one that sends a
		message & doesnt rewind (setPositionImmedate)



PeerToPeer networking model:

	PeerToPeerNetworkModel{
		PeerToPeerNetworkModel();

		void start(StreamConnection *streamConnection,DatagramConnection *datagramConnection);
	}

Client/Server networking model:

	ClientNetworkModel{
		ClientNetworkModel(StreamConnection *streamConnection,DatagramConnection *datagramConnection);

		
	}

	ServertNetworkModel{
		ClientNetworkModel();

		void addClient(StreamConnection *streamConnection,DatagramConnection *datagramConnection);
	}