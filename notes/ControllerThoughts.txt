wm5	Controllers -

	1 Base Class
	Attaches to scene
	Different types to control different objects
	

ogr Controllers -

	2 Interfaces and 1 Class
	2 Values on each end connected by a Function, wrapped by a Controller which updates the dst value from the src.


ogr Animations -

	2 Interfaces and 4 Classes
	AnimatableObject lets you query for AnimatableValues
	AnimatableValues are like a Variant that can be set with anything, and then try to set the other end if its implemented
	AnimationTracks store KeyFrames, of which there are both specific types, Node, Vertex, Numeric.
	Then these AnimationTracks are applied to AnimableValues.
	Animations are a collection of AnimationTracks
	AnimationState is a sort of a utility class, that lets you set times and weights of Animations.
		You query a class for AnimationStates and then set them.
		
		
AnimationState <--- Objects
					Objects ---> Animations
								 Animations ---> AnimationTracks
												 AnimationTracks ---> KeyFrames
												 AnimationTracks ---> AnimatableValues
																	  AnimatableValues <-- AnimatableObject


tlt Animations -
																	  
								Controller --->	Animatable
												TrackAnimation(Animatable) ---> TransformSequence(Resource) ---> TransformKeyFrame
																		   ---> Transformable(A Node could be Transformable)
												MeshAnimation(TrackAnimation) ---> MeshNode
												StudioModelAnimation(Animatable) ---> StudioModelNode
												ScalarAnimation(Animatable) ---> ScalarSequence(Resource)
																			---> Animatable

Controllers can be attached to Nodes, not as Nodes, but a special case, like NodeListeners, and queried by Name or index
																			
MeshController isa Controller which has a MeshNode, and a Bone name.
	It has some extra functions for activateSequence(Name), which finds a TransformSequence of the same name.
		Then a MeshAnimation is created with this Sequence and Bone and added to this Controller.
	deactivateSequence destroys that MeshAnimation
	

We could rename Track/KeyFrame to TransfomTrack/TransformKeyFrame.  Then have TrackAnimations take a
TrackAnimable (an interface which descibes something that can be updated via tracks?)
Or, it can take a list of Animables, then it will index into that list via the Tracks.  Or maybe both.
Or a TrackAnimable takes a list of Animables?

(or, should a TrackAnimation be an Animable?)

Then we can also have a StudioAnimation, which is an Animation/Animable, but takes a StudioModel and controls it.
So StudioAnimations would bypass the whole track system, since they use their own.

Then to animate a studio model:
	StudioModelNode *player;
	Controller *controller=new Controller();
	controller->addAnimation(new StudioModelAnimation(player->getModel()));
	player->addController(controller);
	controller->startAnimation(3);

How I'd like to use it to blend 2 bipedal animations together:
	Controller *legs=mMesh->addController("Legs");
	Controller *body=mMesh->addController("Spine");
	legs->startAnimation("run");
	body->startAnimation("idle");

Animate a camera to follow a path:
	Track *track=new Track();
	track->addKeyFrame(blah);
	TrackAnimation *animation=new TrackAnimation();
	animation->addTrack(track);
	animation->setTransformable(camera);
	Controller *controller=new Controller();
	camera->addController(controller);
	controller->addAnimation();

